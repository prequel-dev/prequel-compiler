package matchz

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *CorrelationT) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "field":
			z.Field, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Field")
				return
			}
		case "strv":
			z.StrValue, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "StrValue")
				return
			}
		case "intv":
			z.IntValue, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IntValue")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z CorrelationT) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "field"
	err = en.Append(0x83, 0xa5, 0x66, 0x69, 0x65, 0x6c, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.Field)
	if err != nil {
		err = msgp.WrapError(err, "Field")
		return
	}
	// write "strv"
	err = en.Append(0xa4, 0x73, 0x74, 0x72, 0x76)
	if err != nil {
		return
	}
	err = en.WriteString(z.StrValue)
	if err != nil {
		err = msgp.WrapError(err, "StrValue")
		return
	}
	// write "intv"
	err = en.Append(0xa4, 0x69, 0x6e, 0x74, 0x76)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.IntValue)
	if err != nil {
		err = msgp.WrapError(err, "IntValue")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CorrelationT) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "field"
	o = append(o, 0x83, 0xa5, 0x66, 0x69, 0x65, 0x6c, 0x64)
	o = msgp.AppendString(o, z.Field)
	// string "strv"
	o = append(o, 0xa4, 0x73, 0x74, 0x72, 0x76)
	o = msgp.AppendString(o, z.StrValue)
	// string "intv"
	o = append(o, 0xa4, 0x69, 0x6e, 0x74, 0x76)
	o = msgp.AppendInt64(o, z.IntValue)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CorrelationT) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "field":
			z.Field, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Field")
				return
			}
		case "strv":
			z.StrValue, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StrValue")
				return
			}
		case "intv":
			z.IntValue, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IntValue")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CorrelationT) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Field) + 5 + msgp.StringPrefixSize + len(z.StrValue) + 5 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *EntityMetadataT) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pid":
			z.ProcessId, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "ProcessId")
				return
			}
		case "mid":
			z.MachineId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "MachineId")
				return
			}
		case "cgrp":
			z.CgroupId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CgroupId")
				return
			}
		case "cid":
			z.ContainerId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ContainerId")
				return
			}
		case "pod":
			z.PodName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PodName")
				return
			}
		case "host":
			z.HostName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HostName")
				return
			}
		case "ns":
			z.Namespace, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Namespace")
				return
			}
		case "fname":
			z.FileName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FileName")
				return
			}
		case "pname":
			z.ProcessName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProcessName")
				return
			}
		case "imgurl":
			z.ImageUrl, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ImageUrl")
				return
			}
		case "cname":
			z.ContainerName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ContainerName")
				return
			}
		case "orig":
			z.Origin, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Origin")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *EntityMetadataT) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 12
	// write "pid"
	err = en.Append(0x8c, 0xa3, 0x70, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.ProcessId)
	if err != nil {
		err = msgp.WrapError(err, "ProcessId")
		return
	}
	// write "mid"
	err = en.Append(0xa3, 0x6d, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.MachineId)
	if err != nil {
		err = msgp.WrapError(err, "MachineId")
		return
	}
	// write "cgrp"
	err = en.Append(0xa4, 0x63, 0x67, 0x72, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.CgroupId)
	if err != nil {
		err = msgp.WrapError(err, "CgroupId")
		return
	}
	// write "cid"
	err = en.Append(0xa3, 0x63, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ContainerId)
	if err != nil {
		err = msgp.WrapError(err, "ContainerId")
		return
	}
	// write "pod"
	err = en.Append(0xa3, 0x70, 0x6f, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.PodName)
	if err != nil {
		err = msgp.WrapError(err, "PodName")
		return
	}
	// write "host"
	err = en.Append(0xa4, 0x68, 0x6f, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.HostName)
	if err != nil {
		err = msgp.WrapError(err, "HostName")
		return
	}
	// write "ns"
	err = en.Append(0xa2, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Namespace)
	if err != nil {
		err = msgp.WrapError(err, "Namespace")
		return
	}
	// write "fname"
	err = en.Append(0xa5, 0x66, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.FileName)
	if err != nil {
		err = msgp.WrapError(err, "FileName")
		return
	}
	// write "pname"
	err = en.Append(0xa5, 0x70, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProcessName)
	if err != nil {
		err = msgp.WrapError(err, "ProcessName")
		return
	}
	// write "imgurl"
	err = en.Append(0xa6, 0x69, 0x6d, 0x67, 0x75, 0x72, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.ImageUrl)
	if err != nil {
		err = msgp.WrapError(err, "ImageUrl")
		return
	}
	// write "cname"
	err = en.Append(0xa5, 0x63, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ContainerName)
	if err != nil {
		err = msgp.WrapError(err, "ContainerName")
		return
	}
	// write "orig"
	err = en.Append(0xa4, 0x6f, 0x72, 0x69, 0x67)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Origin)
	if err != nil {
		err = msgp.WrapError(err, "Origin")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EntityMetadataT) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 12
	// string "pid"
	o = append(o, 0x8c, 0xa3, 0x70, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.ProcessId)
	// string "mid"
	o = append(o, 0xa3, 0x6d, 0x69, 0x64)
	o = msgp.AppendString(o, z.MachineId)
	// string "cgrp"
	o = append(o, 0xa4, 0x63, 0x67, 0x72, 0x70)
	o = msgp.AppendString(o, z.CgroupId)
	// string "cid"
	o = append(o, 0xa3, 0x63, 0x69, 0x64)
	o = msgp.AppendString(o, z.ContainerId)
	// string "pod"
	o = append(o, 0xa3, 0x70, 0x6f, 0x64)
	o = msgp.AppendString(o, z.PodName)
	// string "host"
	o = append(o, 0xa4, 0x68, 0x6f, 0x73, 0x74)
	o = msgp.AppendString(o, z.HostName)
	// string "ns"
	o = append(o, 0xa2, 0x6e, 0x73)
	o = msgp.AppendString(o, z.Namespace)
	// string "fname"
	o = append(o, 0xa5, 0x66, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.FileName)
	// string "pname"
	o = append(o, 0xa5, 0x70, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.ProcessName)
	// string "imgurl"
	o = append(o, 0xa6, 0x69, 0x6d, 0x67, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.ImageUrl)
	// string "cname"
	o = append(o, 0xa5, 0x63, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.ContainerName)
	// string "orig"
	o = append(o, 0xa4, 0x6f, 0x72, 0x69, 0x67)
	o = msgp.AppendBool(o, z.Origin)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EntityMetadataT) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pid":
			z.ProcessId, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProcessId")
				return
			}
		case "mid":
			z.MachineId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MachineId")
				return
			}
		case "cgrp":
			z.CgroupId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CgroupId")
				return
			}
		case "cid":
			z.ContainerId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContainerId")
				return
			}
		case "pod":
			z.PodName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PodName")
				return
			}
		case "host":
			z.HostName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HostName")
				return
			}
		case "ns":
			z.Namespace, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Namespace")
				return
			}
		case "fname":
			z.FileName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FileName")
				return
			}
		case "pname":
			z.ProcessName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProcessName")
				return
			}
		case "imgurl":
			z.ImageUrl, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImageUrl")
				return
			}
		case "cname":
			z.ContainerName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContainerName")
				return
			}
		case "orig":
			z.Origin, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Origin")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EntityMetadataT) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint32Size + 4 + msgp.StringPrefixSize + len(z.MachineId) + 5 + msgp.StringPrefixSize + len(z.CgroupId) + 4 + msgp.StringPrefixSize + len(z.ContainerId) + 4 + msgp.StringPrefixSize + len(z.PodName) + 5 + msgp.StringPrefixSize + len(z.HostName) + 3 + msgp.StringPrefixSize + len(z.Namespace) + 6 + msgp.StringPrefixSize + len(z.FileName) + 6 + msgp.StringPrefixSize + len(z.ProcessName) + 7 + msgp.StringPrefixSize + len(z.ImageUrl) + 6 + msgp.StringPrefixSize + len(z.ContainerName) + 5 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *EntryT) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ts":
			z.Timestamp, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "entry":
			z.Entry, err = dc.ReadBytes(z.Entry)
			if err != nil {
				err = msgp.WrapError(err, "Entry")
				return
			}
		case "spidx":
			z.SpoolIdx, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "SpoolIdx")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *EntryT) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "ts"
	err = en.Append(0x83, 0xa2, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Timestamp)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// write "entry"
	err = en.Append(0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Entry)
	if err != nil {
		err = msgp.WrapError(err, "Entry")
		return
	}
	// write "spidx"
	err = en.Append(0xa5, 0x73, 0x70, 0x69, 0x64, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.SpoolIdx)
	if err != nil {
		err = msgp.WrapError(err, "SpoolIdx")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EntryT) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "ts"
	o = append(o, 0x83, 0xa2, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Timestamp)
	// string "entry"
	o = append(o, 0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
	o = msgp.AppendBytes(o, z.Entry)
	// string "spidx"
	o = append(o, 0xa5, 0x73, 0x70, 0x69, 0x64, 0x78)
	o = msgp.AppendInt64(o, z.SpoolIdx)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EntryT) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ts":
			z.Timestamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "entry":
			z.Entry, bts, err = msgp.ReadBytesBytes(bts, z.Entry)
			if err != nil {
				err = msgp.WrapError(err, "Entry")
				return
			}
		case "spidx":
			z.SpoolIdx, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpoolIdx")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EntryT) Msgsize() (s int) {
	s = 1 + 3 + msgp.Int64Size + 6 + msgp.BytesPrefixSize + len(z.Entry) + 6 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HitsT) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cnt":
			z.Count, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "entries":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Entries")
				return
			}
			if cap(z.Entries) >= int(zb0002) {
				z.Entries = (z.Entries)[:zb0002]
			} else {
				z.Entries = make([]EntryT, zb0002)
			}
			for za0001 := range z.Entries {
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Entries", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Entries", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "ts":
						z.Entries[za0001].Timestamp, err = dc.ReadInt64()
						if err != nil {
							err = msgp.WrapError(err, "Entries", za0001, "Timestamp")
							return
						}
					case "entry":
						z.Entries[za0001].Entry, err = dc.ReadBytes(z.Entries[za0001].Entry)
						if err != nil {
							err = msgp.WrapError(err, "Entries", za0001, "Entry")
							return
						}
					case "spidx":
						z.Entries[za0001].SpoolIdx, err = dc.ReadInt64()
						if err != nil {
							err = msgp.WrapError(err, "Entries", za0001, "SpoolIdx")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Entries", za0001)
							return
						}
					}
				}
			}
		case "corrs":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Correlations")
				return
			}
			if cap(z.Correlations) >= int(zb0004) {
				z.Correlations = (z.Correlations)[:zb0004]
			} else {
				z.Correlations = make([]CorrelationT, zb0004)
			}
			for za0002 := range z.Correlations {
				var zb0005 uint32
				zb0005, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Correlations", za0002)
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Correlations", za0002)
						return
					}
					switch msgp.UnsafeString(field) {
					case "field":
						z.Correlations[za0002].Field, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Correlations", za0002, "Field")
							return
						}
					case "strv":
						z.Correlations[za0002].StrValue, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Correlations", za0002, "StrValue")
							return
						}
					case "intv":
						z.Correlations[za0002].IntValue, err = dc.ReadInt64()
						if err != nil {
							err = msgp.WrapError(err, "Correlations", za0002, "IntValue")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Correlations", za0002)
							return
						}
					}
				}
			}
		case "entity":
			err = z.Entity.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Entity")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HitsT) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "cnt"
	err = en.Append(0x84, 0xa3, 0x63, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	// write "entries"
	err = en.Append(0xa7, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Entries)))
	if err != nil {
		err = msgp.WrapError(err, "Entries")
		return
	}
	for za0001 := range z.Entries {
		// map header, size 3
		// write "ts"
		err = en.Append(0x83, 0xa2, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.Entries[za0001].Timestamp)
		if err != nil {
			err = msgp.WrapError(err, "Entries", za0001, "Timestamp")
			return
		}
		// write "entry"
		err = en.Append(0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
		if err != nil {
			return
		}
		err = en.WriteBytes(z.Entries[za0001].Entry)
		if err != nil {
			err = msgp.WrapError(err, "Entries", za0001, "Entry")
			return
		}
		// write "spidx"
		err = en.Append(0xa5, 0x73, 0x70, 0x69, 0x64, 0x78)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.Entries[za0001].SpoolIdx)
		if err != nil {
			err = msgp.WrapError(err, "Entries", za0001, "SpoolIdx")
			return
		}
	}
	// write "corrs"
	err = en.Append(0xa5, 0x63, 0x6f, 0x72, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Correlations)))
	if err != nil {
		err = msgp.WrapError(err, "Correlations")
		return
	}
	for za0002 := range z.Correlations {
		// map header, size 3
		// write "field"
		err = en.Append(0x83, 0xa5, 0x66, 0x69, 0x65, 0x6c, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.Correlations[za0002].Field)
		if err != nil {
			err = msgp.WrapError(err, "Correlations", za0002, "Field")
			return
		}
		// write "strv"
		err = en.Append(0xa4, 0x73, 0x74, 0x72, 0x76)
		if err != nil {
			return
		}
		err = en.WriteString(z.Correlations[za0002].StrValue)
		if err != nil {
			err = msgp.WrapError(err, "Correlations", za0002, "StrValue")
			return
		}
		// write "intv"
		err = en.Append(0xa4, 0x69, 0x6e, 0x74, 0x76)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.Correlations[za0002].IntValue)
		if err != nil {
			err = msgp.WrapError(err, "Correlations", za0002, "IntValue")
			return
		}
	}
	// write "entity"
	err = en.Append(0xa6, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = z.Entity.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Entity")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HitsT) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "cnt"
	o = append(o, 0x84, 0xa3, 0x63, 0x6e, 0x74)
	o = msgp.AppendUint32(o, z.Count)
	// string "entries"
	o = append(o, 0xa7, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Entries)))
	for za0001 := range z.Entries {
		// map header, size 3
		// string "ts"
		o = append(o, 0x83, 0xa2, 0x74, 0x73)
		o = msgp.AppendInt64(o, z.Entries[za0001].Timestamp)
		// string "entry"
		o = append(o, 0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
		o = msgp.AppendBytes(o, z.Entries[za0001].Entry)
		// string "spidx"
		o = append(o, 0xa5, 0x73, 0x70, 0x69, 0x64, 0x78)
		o = msgp.AppendInt64(o, z.Entries[za0001].SpoolIdx)
	}
	// string "corrs"
	o = append(o, 0xa5, 0x63, 0x6f, 0x72, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Correlations)))
	for za0002 := range z.Correlations {
		// map header, size 3
		// string "field"
		o = append(o, 0x83, 0xa5, 0x66, 0x69, 0x65, 0x6c, 0x64)
		o = msgp.AppendString(o, z.Correlations[za0002].Field)
		// string "strv"
		o = append(o, 0xa4, 0x73, 0x74, 0x72, 0x76)
		o = msgp.AppendString(o, z.Correlations[za0002].StrValue)
		// string "intv"
		o = append(o, 0xa4, 0x69, 0x6e, 0x74, 0x76)
		o = msgp.AppendInt64(o, z.Correlations[za0002].IntValue)
	}
	// string "entity"
	o = append(o, 0xa6, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79)
	o, err = z.Entity.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Entity")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HitsT) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cnt":
			z.Count, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "entries":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Entries")
				return
			}
			if cap(z.Entries) >= int(zb0002) {
				z.Entries = (z.Entries)[:zb0002]
			} else {
				z.Entries = make([]EntryT, zb0002)
			}
			for za0001 := range z.Entries {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Entries", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Entries", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "ts":
						z.Entries[za0001].Timestamp, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Entries", za0001, "Timestamp")
							return
						}
					case "entry":
						z.Entries[za0001].Entry, bts, err = msgp.ReadBytesBytes(bts, z.Entries[za0001].Entry)
						if err != nil {
							err = msgp.WrapError(err, "Entries", za0001, "Entry")
							return
						}
					case "spidx":
						z.Entries[za0001].SpoolIdx, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Entries", za0001, "SpoolIdx")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Entries", za0001)
							return
						}
					}
				}
			}
		case "corrs":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Correlations")
				return
			}
			if cap(z.Correlations) >= int(zb0004) {
				z.Correlations = (z.Correlations)[:zb0004]
			} else {
				z.Correlations = make([]CorrelationT, zb0004)
			}
			for za0002 := range z.Correlations {
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Correlations", za0002)
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Correlations", za0002)
						return
					}
					switch msgp.UnsafeString(field) {
					case "field":
						z.Correlations[za0002].Field, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Correlations", za0002, "Field")
							return
						}
					case "strv":
						z.Correlations[za0002].StrValue, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Correlations", za0002, "StrValue")
							return
						}
					case "intv":
						z.Correlations[za0002].IntValue, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Correlations", za0002, "IntValue")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Correlations", za0002)
							return
						}
					}
				}
			}
		case "entity":
			bts, err = z.Entity.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Entity")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HitsT) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint32Size + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Entries {
		s += 1 + 3 + msgp.Int64Size + 6 + msgp.BytesPrefixSize + len(z.Entries[za0001].Entry) + 6 + msgp.Int64Size
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Correlations {
		s += 1 + 6 + msgp.StringPrefixSize + len(z.Correlations[za0002].Field) + 5 + msgp.StringPrefixSize + len(z.Correlations[za0002].StrValue) + 5 + msgp.Int64Size
	}
	s += 7 + z.Entity.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MatchesT) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ts":
			z.Timestamp, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "spidx":
			z.SpoolIdx, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "SpoolIdx")
				return
			}
		case "rid":
			z.RuleId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RuleId")
				return
			}
		case "rhash":
			z.RuleHash, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RuleHash")
				return
			}
		case "matchid":
			z.MatchId, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "MatchId")
				return
			}
		case "depth":
			z.Depth, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Depth")
				return
			}
		case "ntype":
			z.NodeType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "NodeType")
				return
			}
		case "hits":
			err = z.Hits.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Hits")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MatchesT) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "ts"
	err = en.Append(0x88, 0xa2, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Timestamp)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// write "spidx"
	err = en.Append(0xa5, 0x73, 0x70, 0x69, 0x64, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.SpoolIdx)
	if err != nil {
		err = msgp.WrapError(err, "SpoolIdx")
		return
	}
	// write "rid"
	err = en.Append(0xa3, 0x72, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.RuleId)
	if err != nil {
		err = msgp.WrapError(err, "RuleId")
		return
	}
	// write "rhash"
	err = en.Append(0xa5, 0x72, 0x68, 0x61, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RuleHash)
	if err != nil {
		err = msgp.WrapError(err, "RuleHash")
		return
	}
	// write "matchid"
	err = en.Append(0xa7, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.MatchId)
	if err != nil {
		err = msgp.WrapError(err, "MatchId")
		return
	}
	// write "depth"
	err = en.Append(0xa5, 0x64, 0x65, 0x70, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Depth)
	if err != nil {
		err = msgp.WrapError(err, "Depth")
		return
	}
	// write "ntype"
	err = en.Append(0xa5, 0x6e, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.NodeType)
	if err != nil {
		err = msgp.WrapError(err, "NodeType")
		return
	}
	// write "hits"
	err = en.Append(0xa4, 0x68, 0x69, 0x74, 0x73)
	if err != nil {
		return
	}
	err = z.Hits.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Hits")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MatchesT) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "ts"
	o = append(o, 0x88, 0xa2, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Timestamp)
	// string "spidx"
	o = append(o, 0xa5, 0x73, 0x70, 0x69, 0x64, 0x78)
	o = msgp.AppendInt64(o, z.SpoolIdx)
	// string "rid"
	o = append(o, 0xa3, 0x72, 0x69, 0x64)
	o = msgp.AppendString(o, z.RuleId)
	// string "rhash"
	o = append(o, 0xa5, 0x72, 0x68, 0x61, 0x73, 0x68)
	o = msgp.AppendString(o, z.RuleHash)
	// string "matchid"
	o = append(o, 0xa7, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.MatchId)
	// string "depth"
	o = append(o, 0xa5, 0x64, 0x65, 0x70, 0x74, 0x68)
	o = msgp.AppendUint32(o, z.Depth)
	// string "ntype"
	o = append(o, 0xa5, 0x6e, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.NodeType)
	// string "hits"
	o = append(o, 0xa4, 0x68, 0x69, 0x74, 0x73)
	o, err = z.Hits.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Hits")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MatchesT) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ts":
			z.Timestamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "spidx":
			z.SpoolIdx, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpoolIdx")
				return
			}
		case "rid":
			z.RuleId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RuleId")
				return
			}
		case "rhash":
			z.RuleHash, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RuleHash")
				return
			}
		case "matchid":
			z.MatchId, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MatchId")
				return
			}
		case "depth":
			z.Depth, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Depth")
				return
			}
		case "ntype":
			z.NodeType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NodeType")
				return
			}
		case "hits":
			bts, err = z.Hits.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hits")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MatchesT) Msgsize() (s int) {
	s = 1 + 3 + msgp.Int64Size + 6 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len(z.RuleId) + 6 + msgp.StringPrefixSize + len(z.RuleHash) + 8 + msgp.Uint32Size + 6 + msgp.Uint32Size + 6 + msgp.StringPrefixSize + len(z.NodeType) + 5 + z.Hits.Msgsize()
	return
}